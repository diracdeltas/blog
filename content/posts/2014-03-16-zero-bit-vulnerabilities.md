---
title: Zero-bit vulnerabilities?
author: yan
date: 2014-03-16
url: /zero-bit-vulnerabilities/
categories:
  - code

---
The other day, I overheard Seth Schoen ask the question, &#8220;What is the smallest change you can make to a piece of software to create a serious vulnerability?&#8221; We agreed that one bit is generally <a href="https://en.wikipedia.org/wiki/Off-by-one_error#Fencepost_error" target="_blank">sufficient</a>; for instance, in x86 assembly, the operations JL and JLE (corresponding to &#8220;jump if less than&#8221; and &#8220;jump if less than or equal to&#8221;) are represented by:
  
`The other day, I overheard Seth Schoen ask the question, &#8220;What is the smallest change you can make to a piece of software to create a serious vulnerability?&#8221; We agreed that one bit is generally <a href="https://en.wikipedia.org/wiki/Off-by-one_error#Fencepost_error" target="_blank">sufficient</a>; for instance, in x86 assembly, the operations JL and JLE (corresponding to &#8220;jump if less than&#8221; and &#8220;jump if less than or equal to&#8221;) are represented by:
  
` 

and the difference between the two could very easily cause serious problems via memory corruption or otherwise. As a simple human-understandable example, imagine replacing &#8220;<&#8221; with &#8220;<=&#8221; in a bus ticket machine that says: &#8220;if ticket\_issue\_date < today, reject rider; else allow rider.&#8221;

At this point, I started feeling one-bit-upsmanship and wondered whether there was such a thing as a zero-bit vulnerability. Obviously, a binary that is &#8220;safe&#8221; on one machine can be malicious on a different machine (ex: if the second machine has been infected with malware), so let&#8217;s require that the software must be non-vulnerable and vulnerable on two machines that start in identical states. For simplicity, let&#8217;s also require that both machines are perfectly (read: unrealistically) airgapped, in the sense that there&#8217;s no way for them to change state based on input from other computers.

This seems pretty much impossible to me unless we consider vulnerabilities probabilistically generated by environmental noise during code execution. Two examples for illustration:

  1. A program that behaves in an unsafe way if the character &#8220;A&#8221; is output by a random character generator that uses true hardware randomness (ex: quantum tunneling rates in a semiconductor).
  2. A program that behaves in an unsafe way when there are single-bit flips due to radioactive decay, cosmic ray collisions, background radiation, or other particle interactions in the machine&#8217;s hardware. It turns out that these are <a href="https://en.wikipedia.org/wiki/Soft_error#Causes_of_soft_errors" target="_blank">well-known</a> and have, in some historical cases, caused actual problems. In 2000, Sun <a href="http://www.theregister.co.uk/2001/03/07/sun_suffers_ultrasparc_ii_cache/" target="_blank">reportedly</a> received complaints from 60 clients about an error caused by background radiation that flipped, on average, <a href="http://queue.acm.org/detail.cfm?id=1839574" target="_blank">one bit per processor per year</a>! (In other words, Sun suffers due to sun.)

Which brings up a fun hypothetical question: if you design an SSL library that will always report invalid certificates as valid if ANY one bit in the library is flipped (but behaves correctly in the absence of single-bit flip errors), have you made a zero-bit backdoor?
