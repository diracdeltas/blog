<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Ssl on discrete blogarithm</title>
    <link>https://diracdeltas.github.io/blog/tags/ssl/</link>
    <description>Recent content in Ssl on discrete blogarithm</description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Tue, 31 Dec 2013 00:00:00 +0000</lastBuildDate>
    <atom:link href="https://diracdeltas.github.io/blog/tags/ssl/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>The most subtle joke Iâ€™ve made all year</title>
      <link>https://diracdeltas.github.io/blog/the-most-subtle-joke-ive-made-all-year/</link>
      <pubDate>Tue, 31 Dec 2013 00:00:00 +0000</pubDate>
      
      <guid>https://diracdeltas.github.io/blog/the-most-subtle-joke-ive-made-all-year/</guid>
      <description>&lt;p class=&#34;js-tweet-text tweet-text&#34;&gt;
  &lt;strong&gt;&lt;a href=&#34;https://twitter.com/shefferstroke&#34;&gt;Dan Auerbach&lt;/a&gt;&lt;/strong&gt;: Any doctor can prescribe any medication to anyone. That is a broken system.
&lt;/p&gt;

&lt;p class=&#34;js-tweet-text tweet-text&#34;&gt;
  &lt;a href=&#34;https://twitter.com/bcrypt&#34;&gt;&lt;strong&gt;Yan&lt;/strong&gt;&lt;/a&gt;: Medication needs to be able to do doctor-&lt;a href=&#34;https://www.owasp.org/index.php/Certificate_and_Public_Key_Pinning&#34;&gt;pinning&lt;/a&gt;.
&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Summertime, and the HTTP traffic sniffing is easy</title>
      <link>https://diracdeltas.github.io/blog/summertime-and-the-http-traffic-sniffing-is-easy/</link>
      <pubDate>Fri, 05 Jul 2013 00:00:00 +0000</pubDate>
      
      <guid>https://diracdeltas.github.io/blog/summertime-and-the-http-traffic-sniffing-is-easy/</guid>
      <description>&lt;p&gt;So it happens that every time you access a URL that starts with &amp;#8220;http://&amp;#8221;, anyone on your local network can see what you&amp;#8217;re doing with almost no effort worth writing about. This includes the page itself as well as any information that you&amp;#8217;re transferring, like credit card numbers and passwords (which are hopefully encrypted). It&amp;#8217;s worth reiterating that this isn&amp;#8217;t difficult at all, even if your network is WPA2-protected, as most supposedly-secure WiFi networks are nowadays.&lt;/p&gt;

&lt;p&gt;This sounds like quite a displeasing predicament for those of us who find ourselves using shared wireless networks every day (aka, all of us), but I get the impression that most Internet-users don&amp;#8217;t understand exactly how simple it is to casually sniff HTTP traffic. So, in hopes of convincing you that it *is* in fact simpler than using any OS X package manager successfully, here is the absolute fastest, easiest way I found to reliably eavesdrop on HTTP traffic on most local networks. It should take less than 5 minutes to set up on your Linux thing (maybe also your Mac thing, but I haven&amp;#8217;t tried) and is straightforward to understand.&lt;/p&gt;

&lt;p&gt;(This is intended for education purposes, and also for encouraging more people to use HTTPS instead of HTTP whenever possible, maybe even via the &lt;a href=&#34;https://www.eff.org/https-everywhere/&#34;&gt;browser extension&lt;/a&gt; that I&amp;#8217;m contributing to this summer. More on that in a bit.)&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Run the following to install some packages that we need. dsniff is a collection of various traffic analysis tools, of which we&amp;#8217;ll only use arpspoof; see &lt;a href=&#34;http://www.monkey.org/~dugsong/dsniff/&#34;&gt;here&lt;/a&gt;. tshark is a nice terminal-based packet analyzer; tcpdump also works.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;apt-get install dsniff&lt;/li&gt;
&lt;li&gt;apt-get install tshark&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Turn your machine into ip-forwarding mode as root by flipping a 0 to a 1, or else people on your network won&amp;#8217;t be able to see their websites. Don&amp;#8217;t do this step if you actually want to launch a denial of service attack, I suppose. Also you might want to remember to turn it back to 0 after you&amp;#8217;re done.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;echo &amp;#8220;1&amp;#8221; &amp;gt; /proc/sys/net/ipv4/ip_forward&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Run the following commands as root on a WiFi network. To find your IP address, you can run ifconfig and look for the wlan0__ inet addr. To find your router&amp;#8217;s IP address, you can do something like run &lt;em&gt;traceroute google.com&lt;/em&gt; and pull out the IP address from the first hop, which is likely to be 192.168.x.x.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;arpspoof -i [your IP address] [the router IP address]&lt;/li&gt;
&lt;li&gt;tshark -p port 80 -i wlan0 -T fields -e http.request.method -e http.request.full_uri -e http.user_agent&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;And voila, the second command spews out a stream of HTTP addresses that people on your network are accessing, along with the request method and the type of client software used. This is just the start; you can read the manpage for tshark to figure out how to pull more detailed info from the packets and then start writing scripts to modify them before forwarding them along. Ex: appending &lt;em&gt;-e text&lt;/em&gt; will show HTML data as text from the webpages.&lt;/p&gt;

&lt;p&gt;What we&amp;#8217;ve done so far is:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Perform a attack called &lt;a href=&#34;https://en.wikipedia.org/wiki/ARP_spoofing&#34;&gt;ARP spoofing&lt;/a&gt; on the router. Essentially, we trick everyone on the network into thinking that your computer is the router so that all the traffic intended for the router goes to your computer instead. This is straightforward since ARP doesn&amp;#8217;t include authentication mechanisms.&lt;/li&gt;
&lt;li&gt;Use tshark to extract interesting information from the packets that we&amp;#8217;ve intercepted.&lt;/li&gt;
&lt;li&gt;Forward these packets along to their intended destination so nobody detects our spying.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;While sniffing packets as they floated by on a warm summer night in the attic of a Berkeley farmhouse in the process of testing this out, I could see which HTTP websites my housemates were accessing, what apps they were using on their phones, and what desktop clients they were running without them ever noticing. With a small amount of additional effort and a large amount of additional malice, I could have manipulated their traffic to interchange the titles of Wikipedia articles or whatever else I wanted, the possibilities bounded only by my imagination / knowledge of regular expressions.&lt;/p&gt;

&lt;p&gt;[Note that although WPA2 encrypts data that goes between the router and devices on the network, this clearly doesn&amp;#8217;t prevent eavesdropping via arpspoof by other devices that have access to the network. &lt;a href=&#34;http://security.stackexchange.com/questions/2372/is-wpa2-wifi-protected-against-arp-poisoning-and-sniffing&#34;&gt;Stack Exchange&lt;/a&gt; explains that by operating at a &lt;a href=&#34;https://en.wikipedia.org/wiki/OSI_model&#34;&gt;layer&lt;/a&gt; above that at which WPA encryption occurs, an arpspoof attack causes the data to instead be encrypted for the attacker&amp;#8217;s device instead of the router.]&lt;/p&gt;

&lt;p&gt;Sadface time. On the other hand, none of the above works if you&amp;#8217;re using &lt;a href=&#34;https://en.wikipedia.org/wiki/HTTP_Secure&#34;&gt;HTTPS&lt;/a&gt;, where the S stands for &amp;#8220;secure,&amp;#8221; because in that case traffic is encrypted between you and the server you&amp;#8217;re trying to reach. On the other other hand, outgoing HTTPS requests from your device can still be subtly converted to insecure HTTP via an attack called &lt;a href=&#34;http://www.thoughtcrime.org/software/sslstrip/&#34;&gt;SSLstrip&lt;/a&gt; that makes use of arpspoof if you try to reach an HTTPS site by redirecting from HTTP. On the other other other hand, you can download the EFF&amp;#8217;s &lt;a href=&#34;https://www.eff.org/https-everywhere/&#34;&gt;HTTPS Everywhere extension&lt;/a&gt; for Chrome/Firefox, which rewrites HTTP URLs to HTTPS before you try to connect to the HTTP site. On the (other)*4 hand, there&amp;#8217;s some problems with SSL in practice because of intermediate certificate validation carelessness and so forth. I&amp;#8217;m now out of hands.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Some thoughts on Facebook implementing forward secrecy</title>
      <link>https://diracdeltas.github.io/blog/some-thoughts-on-facebook-implementing-forward-secrecy/</link>
      <pubDate>Thu, 04 Jul 2013 00:00:00 +0000</pubDate>
      
      <guid>https://diracdeltas.github.io/blog/some-thoughts-on-facebook-implementing-forward-secrecy/</guid>
      <description>&lt;p&gt;Last month, &lt;a href=&#34;http://news.cnet.com/8301-13578_3-57591179-38/data-meet-spies-the-unfinished-state-of-web-crypto/&#34;&gt;CNET announced&lt;/a&gt; that Facebook is working on implementing a property called &lt;strong&gt;forward secrecy&lt;/strong&gt; in its encryption of user data. The article is pretty long, but the gist of it is:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Perfect_forward_secrecy&#34;&gt;Forward secrecy&lt;/a&gt; is good news, at least theoretically. Right now, when you send data to Facebook&amp;#8217;s servers, your data gets encrypted so that someone who intercepts your data can&amp;#8217;t read it unless they have Facebook&amp;#8217;s secret key. However, if an eavesdropper is recording your messages now and somehow gets the secret key in the future, they can go back and decrypt all your encrypted communications. Forward secrecy in an encryption protocol, by definition, means that &lt;strong&gt;if the secret key is compromised, your communications are still safe from decryption&lt;/strong&gt;.&lt;/li&gt;
&lt;li&gt;Google is the only major web service that has forward secrecy in its encryption protocol enabled by default. Most services don&amp;#8217;t do this because it&amp;#8217;s computationally expensive.&lt;/li&gt;
&lt;li&gt;The &lt;a href=&#34;http://www.guardian.co.uk/world/2013/jun/08/nsa-prism-server-collection-facebook-google&#34;&gt;leaked slides&lt;/a&gt; about the NSA surveillance program, PRISM, suggest that the NSA is tapping into Internet connections and collecting data in transit between your computer and Facebook&amp;#8217;s servers, or at least that this is possible.&lt;/li&gt;
&lt;li&gt;Once your data is collected by the NSA, it can probably just sit around forever. That gives plenty of time for Facebook&amp;#8217;s secret keys to be brute-forced or obtained by the NSA through a court order. Without perfect secrecy, all your data can be decrypted once this happens.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;So in other words, Facebook is implementing an extra security measure to protect &lt;strong&gt;data in transit&lt;/strong&gt; from users to their servers, and this announcement comes at an opportune time in light of the &lt;a href=&#34;https://en.wikipedia.org/wiki/Perfect_forward_secrecy&#34;&gt;PRISM&lt;/a&gt; revelations in early July.&lt;/p&gt;

&lt;p&gt;But data in transit isn&amp;#8217;t the only kind of data that needs to be protected! What about &lt;strong&gt;data at rest&lt;/strong&gt;?&lt;/p&gt;

&lt;p&gt;To clarify what I mean here, let&amp;#8217;s think about the flow of data from you to your friends when you make a FB post. This is simplified, but it goes something like:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;You type a message in a text box in your web browser and hit send.&lt;/li&gt;
&lt;li&gt;Your browser encrypts that message before it leaves your computer and goes on its way to a Facebook server.&lt;/li&gt;
&lt;li&gt;Your message travels over the Internet in encrypted form.&lt;/li&gt;
&lt;li&gt;Your message reaches a Facebook server, which decrypts the message and stores it in a database so that it can be retrieved later to be shown on your profile, in your friends&amp;#8217; news feeds, in searches, and so forth.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;In Steps 3 and 4, your data goes from in transit to at rest. Here&amp;#8217;s a handy diagram from &lt;a href=&#34;https://en.wikipedia.org/wiki/File:3_states_of_data.jpg&#34;&gt;Wikipedia&lt;/a&gt; that distinguishes the three states of data, which I&amp;#8217;m simplifying into two by merging &amp;#8220;data at rest&amp;#8221; and &amp;#8220;data in use&amp;#8221;:&lt;/p&gt;

&lt;div style=&#34;width: 576px&#34; class=&#34;wp-caption alignnone&#34;&gt;
  &lt;img alt=&#34;&#34; src=&#34;https://upload.wikimedia.org/wikipedia/commons/2/23/3_states_of_data.jpg&#34; width=&#34;566&#34; height=&#34;343&#34; /&gt;
  
  &lt;p class=&#34;wp-caption-text&#34;&gt;
    Three states of data.
  &lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;Nowadays, it&amp;#8217;s expected for major web services to encrypt all data in transit by default using &lt;a href=&#34;https://en.wikipedia.org/wiki/HTTP_Secure&#34;&gt;HTTPS&lt;/a&gt;, which uses the &lt;strong&gt;SSL/TLS&lt;/strong&gt; cryptographic protocols. This is generally done by using a persistent private server key for both &lt;strong&gt;authentication&lt;/strong&gt; (verifying the server&amp;#8217;s identity) and &lt;strong&gt;encryption&lt;/strong&gt; (encoding the data so that only the server can read it). This does not provide forward secrecy, and all encrypted messages are compromised once the persistent server key is found.&lt;/p&gt;

&lt;p&gt;Facebook&amp;#8217;s announcement, which follows one by Google in 2011, reflects a recent shift toward supporting forward secrecy by generating ephemeral Diffie Hellman keys for encryption during each session. A persistent RSA key is still used to authenticate the server. The ephemeral keys used for encryption, however, are &lt;strong&gt;not stored beyond a session&lt;/strong&gt;. Thus, even if the persistent key is compromised, data that has been obtained through eavesdropping on an Internet connection is still safe from decryption.&lt;/p&gt;

&lt;p&gt;However, recall that in Step 4 above, Facebook decrypts your data and stores it in a database, presumably one that is password-protected or has some other security measure that lets a trusted set of people access it (database admins, for instance). At this point, your data is just sitting around in decrypted form, protected by whatever-FB-does-to-protect-its-servers. It would be impractical to do otherwise because performing encrypted query operations efficiently is &lt;a href=&#34;https://en.wikipedia.org/wiki/Homomorphic_encryption&#34; target=&#34;_blank&#34;&gt;hard maths&lt;/a&gt;, and basically the definition of a web app is something that stores data and performs interesting/useful queries.&lt;/p&gt;

&lt;p&gt;With Facebook&amp;#8217;s announcement of support for forward secrecy in TLS/SSL, we&amp;#8217;ve been assured of increased attention to security for data in transit, but this of course says nothing about data at rest. Indeed, it seems that the NSA surveillance leaks have sparked relatively little discussion of policies at companies like Facebook for securing data at rest. That&amp;#8217;s surprising to me, because the oft-spoken phrase &amp;#8220;NSA back door&amp;#8221; vividly suggests that the NSA is in the trusted set of people who have access to the decrypted data in servers at FB, Google, and so forth.&lt;/p&gt;

&lt;p&gt;To be clear, forward secrecy is effective against a particular adversary model, namely wiretapping. Although the CNET article points out that the NSA is probably doing a bunch of wiretapping these days and has agreements with Internet service providers to facilitate such, I assume it&amp;#8217;s still easy for the NSA to walk up to someone at Facebook and demand access to the database. In fact, regardless of how secure data is while in transit, it basically always needs to get decrypted on the server side in order to be useful for a web service. As long as it&amp;#8217;s easy for the web service to access the decrypted data, it&amp;#8217;s easy for the NSA to do so as well*.&lt;/p&gt;

&lt;p&gt;*Barring policy changes that would legally prevent surveillance. Even so &amp;hellip;&lt;/p&gt;

&lt;p&gt;In short, there probably exists no NSA-proof cryptographic protocol for securing data at rest so long as companies agree to comply with gov-authorized surveillance programs. Forward secrecy doesn&amp;#8217;t seem like much of a deterrent to PRISM in that case.&lt;/p&gt;

&lt;p&gt;But in terms of protecting our privacy from attackers who &lt;strong&gt;aren&amp;#8217;t&lt;/strong&gt; government spying agencies, the security of data at rest matters as much as, if not more than, security for data in transit. Unfortunately, whereas TLS/SSL is an established and widely-used standard for encrypting data in transit (albeit flawed in practice), procedures for securing data at rest seem to vary widely between companies (see Appendix A). These procedures are often described in vague terms if at all. For instance, &lt;a href=&#34;https://www.cloze.com/&#34;&gt;one service&lt;/a&gt; simply states that it &amp;#8220;provides multiple layers of security around your information, from access protected data centers, through network and application level security &amp;hellip; Sensitive information, such as your email, messages and passwords, is always encrypted.&amp;#8221; The methods of encryption, whether they are applied in transit or at rest, and other important details related to the security of the service are left out.&lt;/p&gt;

&lt;p&gt;It&amp;#8217;s hard to blame the product description writers for omitting these crucial details, because most users simply don&amp;#8217;t care as long as they feel reasonably secure. It&amp;#8217;s easy to feel secure with assurances like the ones quoted above, and news articles about implementations of forward secrecy in the works at FB. And then you get things like &lt;a href=&#34;http://thenextweb.com/twitter/2012/12/20/twitter-com-login-flaw-causes-passwords-to-be-sent-in-plain-text-in-some-cases/&#34;&gt;Twitter sending passwords in unencrypted form&lt;/a&gt; or &lt;a href=&#34;https://www.trustwave.com/spiderlabs/advisories/TWSL2011-007.txt&#34;&gt;Apple failing to properly authenticate SSL certificates&lt;/a&gt; or a whole &lt;a href=&#34;http://plaintextoffenders.com/&#34;&gt;Tumblr blog of websites that store and send passwords in plaintext&lt;/a&gt;, oops. There&amp;#8217;s a difference between feeling secure and actually being secure on the web, clearly, but paranoia is tiring and you should probably go check on the 12 Facebook notifications that you got while reading this blog post.&lt;/p&gt;

&lt;p&gt;===========&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Appendix A: A Brief, Non-Representative Survey of Company Policies for Securing Data at Rest&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;In the course of researching this blog post, I made a post on a certain social media site asking my friends in tech about how their companies secured non-sensitive data at rest, where non-sensitive data includes user-to-user communications and metadata (but not passwords, SSNs, and financial data). The few answers I got were more sophisticated than, &amp;#8220;In plaintext, on a password-protected database,&amp;#8221; but I suspect there&amp;#8217;s some selection bias here. Anonymized responses below.&lt;/p&gt;

&lt;p&gt;_&lt;strong&gt;_&lt;/strong&gt;_&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;I&amp;#8217;ve worked with so many apps, and it&amp;#8217;s almost always a database behind a firewall. I&amp;#8217;ve occasionally built systems where financial data was stored in some more secure way: one, where financial data and transaction processing happened on a separate box with no services and a very minimal API (to limit exposure), and where it was impossible to retrieve the sensitive information via the API.&lt;br data-reactid=&#34;.r[n8ym].[0]{comment10200377727028310_4734438}.[2:0].[5:0:right].[4:1].[5:0:left].[2:1].[2:0].[2:0:2].[3:0].[4:0:1]&#34; /&gt;&lt;br data-reactid=&#34;.r[n8ym].[0]{comment10200377727028310_4734438}.[2:0].[5:0:right].[4:1].[5:0:left].[2:1].[2:0].[2:0:2].[3:0].[4:0:2]&#34; /&gt;The other one actually encrypted data using a key that was secured with the user&amp;#8217;s password. It was re-encrypted using the user&amp;#8217;s session on login, so the cleartext was only available when the user was logged in, during a request from that specific client. In this way, sensitive information was protected from our staff, and from an attacker, except that anyone who was actively using the system would be exposed (to a reasonably sophisticated attacker).&lt;br data-reactid=&#34;.r[n8ym].[0]{comment10200377727028310_4734438}.[2:0].[5:0:right].[4:1].[5:0:left].[2:1].[2:0].[2:0:2].[3:0].[4:0:4]&#34; /&gt;&lt;br data-reactid=&#34;.r[n8ym].[0]{comment10200377727028310_4734438}.[2:0].[5:0:right].[4:1].[5:0:left].[2:1].[2:0].[2:0:2].[3:0].[4:0:5]&#34; /&gt;None of these ideas provide protection from a government, though. Client-side encryption doesn&amp;#8217;t really, either. Just look at what happened to Hushmail. I really want there to be some trustable encryption API in the browser, so that client-side encryption for web apps could be a real thing.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;_&lt;strong&gt;_&lt;/strong&gt;_&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;We actually encrypt (with a separately stored per-user key) all of our user message content. It makes me way way more comfortable debugging problems that come up in production knowing I&amp;#8217;m not going to accidentally read a message that was meant for a friend or co-worker. It&amp;#8217;s pretty low-effort and low-resource-intensity for us to do this so it seems silly not to.&lt;/p&gt;

&lt;p&gt;I guess the tradeoff is that for somebody like Facebook they&amp;#8217;d lose the ability to do queries in aggregate to make advertising or similar decisions based on content.&lt;/p&gt;

&lt;p&gt;&amp;hellip; the keys [for encrypting messages] are stored with symmetric encryption. It defends us against outside attackers getting use out of dumps of our database but in theory with access to the layer that gets the messages and has the keys the encryption doesn&amp;#8217;t matter. The practical limit when we&amp;#8217;ve looked at doing more is one where as long as our site can display your messages then there&amp;#8217;s some set of our infrastructure an attacker could use to read those.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;_&lt;strong&gt;_&lt;/strong&gt;_&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;We use client-side encryption with client-generated keys for user history/bookmarks/passwords, etc. So adding a device to access said data involves JPAKE (key exchange) via our servers (which are treated as an untrusted 3rd party).&lt;/p&gt;

&lt;p&gt;This means syncing is hard, but we associate each record with a record ID and sync them if the hash changes.&lt;/p&gt;

&lt;p&gt;For telemetry, we use anonymized data &amp;#8211; uploads are linked to a UUID that only the client stores locally.&lt;/p&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
  </channel>
</rss>